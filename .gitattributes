#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>

#define MAX_PATH_LEN 256

static void usage(const char *progname) {
    fprintf(stderr, "Usage: %s [-u|-p|-h][-l|-e <path>]\n", progname);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  -u, --users    List users and their home directories\n");
    fprintf(stderr, "  -p, --processes  List running processes\n");
    fprintf(stderr, "  -h, --help     Show this usage message\n");
    fprintf(stderr, "  -l <path>, --log <path>   Redirect output to the specified path\n");
    fprintf(stderr, "  -e <path>, --errors <path> Redirect error output (stderr) to the specified path\n");
}

static int list_users(FILE *output) {
    struct dirent *dp;
    DIR *dirp = opendir("/etc/passwd");
    if (!dirp) {
        perror("opendir");
        return 1;
    }
    while ((dp = readdir(dirp)) != NULL) {
        if (dp->d_name[0] != '.') {
            char path[MAX_PATH_LEN];
            snprintf(path, sizeof(path), "/etc/passwd/%s", dp->d_name);

            FILE *f = fopen(path, "r");
            if (!f) {
                perror("fopen");
                closedir(dirp);
                return 1;
            }

            char line[MAX_PATH_LEN];
            char username[MAX_PATH_LEN];
            char homedir[MAX_PATH_LEN];

            while (fgets(line, sizeof(line), f) != NULL) {
                if (sscanf(line, "%s:%*s:%*d:%*d:%*s:%s", username, homedir) == 2) {
                    fprintf(output, "%s: %s\n", username, homedir);
                }
            }

            fclose(f);
        }
    }

    closedir(dirp);
    return 0;
}

static int list_processes(FILE *output) {
    char cmd[] = "ps -e -o pid,cmd";

    FILE *pipe = popen(cmd, "r");
    if (!pipe) {
        perror("popen");
        return 1;
    }

    char line[MAX_PATH_LEN];
    int pid;
    char command[MAX_PATH_LEN];

    while (fgets(line, sizeof(line), pipe) != NULL) {
        if (sscanf(line, "%d %s", &pid, command) == 2) {
            fprintf(output, "%d: %s\n", pid, command);
        }
    }

    pclose(pipe);
    return 0;
}

static int redirect_output(const char *path) {
    FILE *f = fopen(path, "w");
    if (!f) {
        perror("fopen");
        return 1;
    }

    int ret = dup2(fileno(f), STDOUT_FILENO);
    if (ret < 0) {
        perror("dup2");
        fclose(f);
        return 1;
    }

    return 0;
}

static int redirect_errors(const char *path) {
    FILE *f = fopen(path, "w");
    if (!f) {
        perror("fopen");
        return 1;
    }

    int ret = dup2(fileno(f), STDERR_FILENO);
    if (ret < 0) {
        perror("dup2");
        fclose(f);
        return 1;
    }

    return 0;
}

int main(int argc, char *argv) {
    const char *short_options = "uphle:";
    const struct option long_options[] = {
        {"users", no_argument, NULL, 'u'},
        {"processes", no_argument, NULL, 'p'},
        {"help", no_argument, NULL, 'h'},
        {"log", required_argument, NULL, 'l'},
        {"errors", required_argument, NULL, 'e'},
        {NULL, 0, NULL, 0}
    };

    FILE *output = stdout;
    FILE *errors = stderr;

    int c;
    optind = 1;
    while ((c = getopt_long(argc, argv, short_options, long_options, NULL)) != -1) {
        switch (c) {
            case 'u':
                list_users(output);
                break;
            case 'p':
                list_processes(output);
                break;
            case 'h':
                usage(argv[0]);
                return 0;
            case 'l':
                if (redirect_output(optarg) != 0)
{
                    fprintf(stderr, "Error redirecting output to %s\n", optarg);
                    return 1;
                }
                break;
            case 'e':
                if (redirect_errors(optarg) != 0) {
                    fprintf(stderr, "Error redirecting errors to %s\n", optarg);
                    return 1;
                }
                break;
            default:
                usage(argv[0]);
                return 1;
        }
    }

    return 0;
}
